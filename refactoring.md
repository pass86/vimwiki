# 重构的重新认识
* 重构是在不改变软件可观察行为的前提下改善其内部结构

# 重构的第一步
* 我得为即将修改的代码建立一组可靠的测试环境

# 分解并重组statement()
* 任何一个傻瓜都能写出计算机可以理解的代码。唯有写出人类容易理解的代码，才是优秀的程序员。
* 代码应该表现自己的目的，这一点非常重要
* 绝大多数情况下，函数应该放在它使用的数据的所属对象内

# 运用多态取代与价格相关的条件逻辑
* 最好不要在另一个对象的属性基础上运用switch语句。如果不得不使用，也应该在对象自己的数据上使用，而不是在别人的数据上使用。
* Replace Type Code with State/Strategy
* Move Method
* Replace Conditional with Polymorphism

# 结语
* 这个例子给我们最大的启发是重构的节奏：测试、小修改、测试、小修改、测试、小修改......正是这种节奏让重构得以快速而安全地前进

# 何谓重构
* 重构（名词）：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本
* 重构（动词）：使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构

# 何时重构
* 事不过三，三则重构
* 难以阅读的程序，难以修改
* 逻辑重复的程序，难以修改
* 添加新行为时需要修改已有代码的程序，难以修改
* 带复杂条件逻辑的程序，难以修改

# 重构的难题
* 重写（而非重构）的一个清楚讯号就是：现有代码根本不能正常运作
* 如果项目已近最后期限，你也应该避免重构

# Long Method（过长函数）
* “间接层”所能带来的全部利益--解释能力、共享能力、选择能力--都是由小型函数支持的
* 每当感觉需要以注释来说明点什么的时候，我们就把需要说明的东西写进一个独立函数中，并以其用途（而非实现手法）命名

# 自测试代码的价值
* 编写测试代码其实就是在问自己：添加这个功能需要做些什么
* 编写测试代码还能使你把注意力集中于接口而非实现（这永远是件好事）

# 单元测试和功能测试
* 每当你收到bug报告，请先写一个单元测试来暴露这个bug

# 添加更多测试
* 测试的要诀是：测试你最担心出错的部分
* 测试的一项重要技巧就是“寻找边界条件”

# 这些重构手法有多熟
* 模式是你希望到达的目标，重构则是到达之路。

# Extract Method（提炼函数）
* 将这段代码放进一个独立函数中，并让函数名称解释该函数的用途
* 这会使高层函数读起来就像一系列注释

# Inline Method（内联函数）
* 在函数调用点插入本体，然后移除该函数
* 间接性可能带来帮助，但非必要的间接性总是让人不舒服

# Inline Temp（内联临时变量）
* 将所有对该变量的引用动作，替换为对它赋值的那个表达式自身
* 多半是作为Replace Temp with Query的一部分使用的

# Replace Temp with Query（以查询取代临时变量）
* 将这个表达式提炼到一个独立函数中。将这个临时变量的所有引用点替换为对新函数的调用。此后，新函数就可被其他函数使用。
* 由于临时变量只在所属函数内可见，所以它们会驱使你写出更长的函数
* 找出只被赋值一次的临时变量

# Introduce Explaining Variable（引入解释性变量）
* 将该复杂表达式（或其中一部分）的结果放进一个临时变量，以此变量名称来解释表达式用途
* 表达式有可能非常复杂而难以阅读

# Split Temporary Variable（分解临时变量）
* 针对每次赋值，创造一个独立、对应的临时变量
* 同一个临时变量承担两件不同的事情，会令代码阅读者糊涂

# Remove Assignments to Parameters（移除对参数的赋值）
* 因为它降低了代码的清晰度
* 如果需要返回的值不止一个，看看可否把需返回的大堆数据变成单一对象，或干脆为每个返回值设计对应的一个独立函数

# Replace Method with Method Object（以函数对象取代函数）
* 将这个函数放进一个单独对象中，如此一来局部变量就成了对象内的字段。然后你可以在同一个对象中将这个大型函数分解为多个小型函数。
* 如果一个函数之中局部变量泛滥成灾，那么想分解这个函数是非常困难的

# Substitute Algorithm（替换算法）
* 将函数本体替换为另一个算法
* 如果你发现做一件事可以有更清晰的方式，就应该以较清晰的方式取代复杂的方式

# Move Method（搬移函数）
* 在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或是将旧函数完全移除。
* 会根据“这个函数与哪个对象的交流比较多”，决定其移动路径

# Move Field（搬移字段）
* 在目标类新建一个字段，修改源字段的所有用户，令它们改用新的字段
* 对于一个字段，在其所驻类之外的另一个类中有更多函数使用了它，我就会考虑搬移这个字段

# Extract Class（提炼类）
* 建立一个新类，将相关的字段和函数从旧类搬移到新类
* 这样的类往往含有大量函数和数据

# Inline Class（将类内联化）
* 某个类没有做太多事情
* 将这个类的所有特性搬移到另一个类中，然后移除原类

# Hide Delegate（隐藏“委托关系”）
* 在服务类上建立客户所需的所有函数，用以隐藏委托关系
* 这么一来，即便将来发生委托关系上的变化，变化也将被限制在服务对象中，不会波及客户

# Remove Middle Man（移除中间人）
* 某个类做了过多的简单委托动作
* 让客户直接调用受托类
* 重构的意义就在于：你永远不必说对不起--只要把出问题的地方修补好就行了
