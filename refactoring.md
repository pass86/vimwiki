重构，第一个案例
================
# 重构的重新认识
* 重构是在不改变软件可观察行为的前提下改善其内部结构

# 重构的第一步
* 我得为即将修改的代码建立一组可靠的测试环境

# 分解并重组statement()
* 任何一个傻瓜都能写出计算机可以理解的代码。唯有写出人类容易理解的代码，才是优秀的程序员。
* 代码应该表现自己的目的，这一点非常重要
* 绝大多数情况下，函数应该放在它使用的数据的所属对象内

# 运用多态取代与价格相关的条件逻辑
* 最好不要在另一个对象的属性基础上运用switch语句。如果不得不使用，也应该在对象自己的数据上使用，而不是在别人的数据上使用。

# 结语
* 这个例子给我们最大的启发是重构的节奏：测试、小修改、测试、小修改、测试、小修改......正是这种节奏让重构得以快速而安全地前进

重构原则
========
# 何谓重构
* 重构（名词）：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本
* 重构（动词）：使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构

# 何时重构
* 事不过三，三则重构
* 难以阅读的程序，难以修改
* 逻辑重复的程序，难以修改
* 添加新行为时需要修改已有代码的程序，难以修改
* 带复杂条件逻辑的程序，难以修改

# 重构的难题
* 重写（而非重构）的一个清楚讯号就是：现有代码根本不能正常运作
* 如果项目已近最后期限，你也应该避免重构

代码的坏味道
============
# Long Method（过长函数）
* “间接层”所能带来的全部利益--解释能力、共享能力、选择能力--都是由小型函数支持的
* 每当感觉需要以注释来说明点什么的时候，我们就把需要说明的东西写进一个独立函数中，并以其用途（而非实现手法）命名

构筑测试体系
============
# 自测试代码的价值
* 编写测试代码其实就是在问自己：添加这个功能需要做些什么
* 编写测试代码还能使你把注意力集中于接口而非实现（这永远是件好事）

# 单元测试和功能测试
* 每当你收到bug报告，请先写一个单元测试来暴露这个bug

# 添加更多测试
* 测试的要诀是：测试你最担心出错的部分
* 测试的一项重要技巧就是“寻找边界条件”

重构列表
========
# 这些重构手法有多熟
* 模式是你希望到达的目标，重构则是到达之路。

重新组织函数
============
# Extract Method（提炼函数）
* 将这段代码放进一个独立函数中，并让函数名称解释该函数的用途
* 这会使高层函数读起来就像一系列注释

# Inline Method（内联函数）
* 在函数调用点插入本体，然后移除该函数
* 间接性可能带来帮助，但非必要的间接性总是让人不舒服

# Inline Temp（内联临时变量）
* 将所有对该变量的引用动作，替换为对它赋值的那个表达式自身
* 多半是作为Replace Temp with Query的一部分使用的

# Replace Temp with Query（以查询取代临时变量）
* 将这个表达式提炼到一个独立函数中。将这个临时变量的所有引用点替换为对新函数的调用。此后，新函数就可被其他函数使用。
* 由于临时变量只在所属函数内可见，所以它们会驱使你写出更长的函数
* 找出只被赋值一次的临时变量

# Introduce Explaining Variable（引入解释性变量）
* 将该复杂表达式（或其中一部分）的结果放进一个临时变量，以此变量名称来解释表达式用途
* 表达式有可能非常复杂而难以阅读

# Split Temporary Variable（分解临时变量）
* 针对每次赋值，创造一个独立、对应的临时变量
* 同一个临时变量承担两件不同的事情，会令代码阅读者糊涂

# Remove Assignments to Parameters（移除对参数的赋值）
* 因为它降低了代码的清晰度
* 如果需要返回的值不止一个，看看可否把需返回的大堆数据变成单一对象，或干脆为每个返回值设计对应的一个独立函数

# Replace Method with Method Object（以函数对象取代函数）
* 将这个函数放进一个单独对象中，如此一来局部变量就成了对象内的字段。然后你可以在同一个对象中将这个大型函数分解为多个小型函数。
* 如果一个函数之中局部变量泛滥成灾，那么想分解这个函数是非常困难的

# Substitute Algorithm（替换算法）
* 将函数本体替换为另一个算法
* 如果你发现做一件事可以有更清晰的方式，就应该以较清晰的方式取代复杂的方式

在对象之间搬移特性
==================
# Move Method（搬移函数）
* 在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或是将旧函数完全移除。
* 会根据“这个函数与哪个对象的交流比较多”，决定其移动路径

# Move Field（搬移字段）
* 在目标类新建一个字段，修改源字段的所有用户，令它们改用新的字段
* 对于一个字段，在其所驻类之外的另一个类中有更多函数使用了它，我就会考虑搬移这个字段

# Extract Class（提炼类）
* 建立一个新类，将相关的字段和函数从旧类搬移到新类
* 这样的类往往含有大量函数和数据

# Inline Class（将类内联化）
* 某个类没有做太多事情
* 将这个类的所有特性搬移到另一个类中，然后移除原类

# Hide Delegate（隐藏“委托关系”）
* 在服务类上建立客户所需的所有函数，用以隐藏委托关系
* 这么一来，即便将来发生委托关系上的变化，变化也将被限制在服务对象中，不会波及客户

# Remove Middle Man（移除中间人）
* 某个类做了过多的简单委托动作
* 让客户直接调用受托类
* 重构的意义就在于：你永远不必说对不起--只要把出问题的地方修补好就行了

# Introduce Foreign Method（引入外加函数）
* 在客户类中建立一个函数，并以第一参数形式传入一个服务类实例
* 你又需要一项新服务，这个类却无法供应

# Introduce Local Extension（引入本地扩展）
* 建立一个新类，使它包含这些额外函数。让这个扩展品成为源类的之类或者包装类
* 两种标准对象技术--子类化（subclassing）和包装（wrapping）--是显而易见的办法

重新组织数据
============
# Self Encapsulate Field（自封装字段）
* 为这个字段建立取值/设值函数，并且只以这些函数来访问字段
* 间接访问变量的好处是，子类可以通过覆写一个函数而改变获取数据的途径；它还支持更灵活的数据管理方式，如延迟初始化
* 我比较喜欢先使用直接访问方式，直到这种方式给我带来麻烦为止

# Replace Data Value with Object（以对象取代数据值）
* 将数据项变成对象
* 这些简单数据项不再那么简单了

# Change Value to Reference（将值对象改为引用对象）
* 你可能会希望给这个对象加入一些可修改数据， 并确保对任何一个对象的修改都能影响到所有引用此一对象的地方

# Change Reference to Value（将引用对象改为值对象）
* 值对象有一个非常重要的特性：它们应该是不可变的

# Replace Array with Object（以对象取代数组）
* 一个数组容纳了多种不同对象，这会给用户带来麻烦

# Duplicate Observed Data（复制“被监视数据”）
* 将该数据复制到一个领域对象中。建立一个Observer模式，用以同步领域对象和GUI对象内的重复数据。
* 一个分层良好的系统，应该将处理用户界面和处理业务逻辑的代码分开

# Change Unidirectional Association to Bidirectional（将单向关联改为双向关联）
* 添加一个反向指针，并使修改函数能够同时更新两条连接
* 如果使用不当，反向指针很容易造成混乱
* 如果某个对象是组成另一对象的部件，那么由后者负责控制关联关系

# Change Bidirectional Association to Unidirectional（将双向关联改为单向关联）
* 去除不必要的关联
* 大量的双向连接也很容易造成“僵尸对象”

# Replace Magic Number with Symbolic Constant（以字面量取代魔法数）
* 创造一个常量，根据其意义为它命名，并将上述的字面数值替换为这个常量
* 常量不会造成任何性能开销，却可以大大提高代码的可读性

# Encapsulate Field（封装字段）
* 将它声明为private，并提供相应的访问函数
* 面向对象的首要原则之一就是封装，或者称为“数据隐藏”

# Encapsulate Collection（封装集合）
* 让这个函数返回该集合的一个只读副本，并在这个类中提供添加/移除集合元素的函数
* 取值函数不该返回集合自身，因为这会让用户得以修改集合内容而集合拥有者却一无所悉

# Replace Record with Data（以数据类取代记录）
* 为该记录创建一个“哑”数据对象

# Replace Type Code with Class（以类取代类型码）
* 以一个新的类替换该数值类型码
* 如果把那样的数值换成一个类，编译器就可以对这个类进行类型检验

# Replace Type Code with Subclasses（以子类取代类型码）
* 但如果类型码会影响主类的行为，那么最好的办法就是借助多态来处理变化行为
* 以类型码的宿主类为基类，针对每种类型码建立相应的子类

# Replace Type Code with State/Strategy（以State/Strategy取代类型码）
* 但如果“类型码的值在对象生命周期中发生变化”或“其他原因使得宿主类不能被继承”，你也可以使用本重构
* 在超类中建立一个抽象的查询函数，用以返回类型码。在每个子类中覆写该函数，返回确切的类型码
* 对象的类型码是可变的，所以我不能使用继承方式来处理类型码

# Replace Subclass with Fields（以字段取代子类）
* 若子类中只有常量函数，实在没有足够的存在价值

简化条件表达式
==============
# Decompose Conditional（分解条件表达式）
* 复杂的条件逻辑是最常导致复杂度上升的地点之一
* 提炼出来的函数可读性也更高一些--它看上去就像一段注释那样清楚而明白

# Consolidate Conditional Expression(合并条件表达式)
* 将检查条件提炼成一个独立的函数对于厘清代码意义非常有用，因为它把描述“做什么”的语句换成了“为什么这样做”

# Consolidate Duplicate Conditional Fragments(合并重复的条件片段)
* 一组条件表达式的所有分支都执行了相同的代码

# Remove Control Flag(移除控制标记)
* 以break语句或return语句取代控制标记

# Replace Nested Conditional with Guard Clauses(以卫语句取代嵌套表达式)
* 给某一条分支以特别的重视
