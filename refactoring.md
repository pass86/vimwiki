# 重构的重新认识
* 重构是在不改变软件可观察行为的前提下改善其内部结构

# 重构的第一步
* 我得为即将修改的代码建立一组可靠的测试环境

# 分解并重组statement()
* 任何一个傻瓜都能写出计算机可以理解的代码。唯有写出人类容易理解的代码，才是优秀的程序员。
* 代码应该表现自己的目的，这一点非常重要
* 绝大多数情况下，函数应该放在它使用的数据的所属对象内

# 运用多态取代与价格相关的条件逻辑
* 最好不要在另一个对象的属性基础上运用switch语句。如果不得不使用，也应该在对象自己的数据上使用，而不是在别人的数据上使用。
* Replace Type Code with State/Strategy
* Move Method
* Replace Conditional with Polymorphism

# 结语
* 这个例子给我们最大的启发是重构的节奏：测试、小修改、测试、小修改、测试、小修改......正是这种节奏让重构得以快速而安全地前进

# 何谓重构
* 重构（名词）：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本
* 重构（动词）：使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构

# 何时重构
* 事不过三，三则重构
* 难以阅读的程序，难以修改
* 逻辑重复的程序，难以修改
* 添加新行为时需要修改已有代码的程序，难以修改
* 带复杂条件逻辑的程序，难以修改

# 重构的难题
* 重写（而非重构）的一个清楚讯号就是：现有代码根本不能正常运作
* 如果项目已近最后期限，你也应该避免重构

# Long Method（过长函数）
* “间接层”所能带来的全部利益--解释能力、共享能力、选择能力--都是由小型函数支持的
* 每当感觉需要以注释来说明点什么的时候，我们就把需要说明的东西写进一个独立函数中，并以其用途（而非实现手法）命名

# 自测试代码的价值
* 编写测试代码其实就是在问自己：添加这个功能需要做些什么
* 编写测试代码还能使你把注意力集中于接口而非实现（这永远是件好事）

# 单元测试和功能测试
* 每当你收到bug报告，请先写一个单元测试来暴露这个bug

# 添加更多测试
* 测试的要诀是：测试你最担心出错的部分
* 测试的一项重要技巧就是“寻找边界条件”

# 这些重构手法有多熟
* 模式是你希望到达的目标，重构则是到达之路。

# Extract Method（提炼函数）
* 将这段代码放进一个独立函数中，并让函数名称解释该函数的用途
* 这会使高层函数读起来就像一系列注释

# Inline Method（内联函数）
* 在函数调用点插入本体，然后移除该函数
* 间接性可能带来帮助，但非必要的间接性总是让人不舒服

# Inline Temp（内联临时变量）
* 将所有对该变量的引用动作，替换为对它赋值的那个表达式自身
* 多半是作为Replace Temp with Query的一部分使用的

# Replace Temp with Query（以查询取代临时变量）
* 将这个表达式提炼到一个独立函数中。将这个临时变量的所有引用点替换为对新函数的调用。此后，新函数就可被其他函数使用。
* 由于临时变量只在所属函数内可见，所以它们会驱使你写出更长的函数
* 找出只被赋值一次的临时变量

# Introduce Explaining Variable（引入解释性变量）
* 将该复杂表达式（或其中一部分）的结果放进一个临时变量，以此变量名称来解释表达式用途
* 表达式有可能非常复杂而难以阅读

# Split Temporary Variable（分解临时变量）
* 针对每次赋值，创造一个独立、对应的临时变量
* 同一个临时变量承担两件不同的事情，会令代码阅读者糊涂

# Remove Assignments to Parameters（移除对参数的赋值）
* 因为它降低了代码的清晰度
* 如果需要返回的值不止一个，看看可否把需返回的大堆数据变成单一对象，或干脆为每个返回值设计对应的一个独立函数

# Replace Method with Method Object（以函数对象取代函数）
* 将这个函数放进一个单独对象中，如此一来局部变量就成了对象内的字段。然后你可以在同一个对象中将这个大型函数分解为多个小型函数。
* 如果一个函数之中局部变量泛滥成灾，那么想分解这个函数是非常困难的

# Substitute Algorithm（替换算法）
* 将函数本体替换为另一个算法
* 如果你发现做一件事可以有更清晰的方式，就应该以较清晰的方式取代复杂的方式

# Move Method（搬移函数）
* 在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或是将旧函数完全移除。
* 会根据“这个函数与哪个对象的交流比较多”，决定其移动路径

# Move Field（搬移字段）
* 在目标类新建一个字段，修改源字段的所有用户，令它们改用新的字段
* 对于一个字段，在其所驻类之外的另一个类中有更多函数使用了它，我就会考虑搬移这个字段

# Extract Class（提炼类）
* 建立一个新类，将相关的字段和函数从旧类搬移到新类
* 这样的类往往含有大量函数和数据

# Inline Class（将类内联化）
* 某个类没有做太多事情
* 将这个类的所有特性搬移到另一个类中，然后移除原类

# Hide Delegate（隐藏“委托关系”）
* 在服务类上建立客户所需的所有函数，用以隐藏委托关系
* 这么一来，即便将来发生委托关系上的变化，变化也将被限制在服务对象中，不会波及客户

# Remove Middle Man（移除中间人）
* 某个类做了过多的简单委托动作
* 让客户直接调用受托类
* 重构的意义就在于：你永远不必说对不起--只要把出问题的地方修补好就行了

# Introduce Foreign Method（引入外加函数）
* 在客户类中建立一个函数，并以第一参数形式传入一个服务类实例
* 你又需要一项新服务，这个类却无法供应

# Introduce Local Extension（引入本地扩展）
* 建立一个新类，使它包含这些额外函数。让这个扩展品成为源类的之类或者包装类
* 两种标准对象技术--子类化（subclassing）和包装（wrapping）--是显而易见的办法

# Self Encapsulate Field（自封装字段）
* 为这个字段建立取值/设值函数，并且只以这些函数来访问字段
* 间接访问变量的好处是，子类可以通过覆写一个函数而改变获取数据的途径；它还支持更灵活的数据管理方式，如延迟初始化
* 我比较喜欢先使用直接访问方式，直到这种方式给我带来麻烦为止

# Replace Data Value with Object（以对象取代数据值）
* 将数据项变成对象
* 这些简单数据项不再那么简单了

# Change Value to Reference（将值对象改为引用对象）
* 你可能会希望给这个对象加入一些可修改数据， 并确保对任何一个对象的修改都能影响到所有引用此一对象的地方

# Change Reference to Value（将引用对象改为值对象）
* 值对象有一个非常重要的特性：它们应该是不可变的

# Replace Array with Object（以对象取代数组）
* 一个数组容纳了多种不同对象，这会给用户带来麻烦

# Duplicate Observed Data（复制“被监视数据”）
* 将该数据复制到一个领域对象中。建立一个Observer模式，用以同步领域对象和GUI对象内的重复数据。
* 一个分层良好的系统，应该将处理用户界面和处理业务逻辑的代码分开

# Change Unidirectional Association to Bidirectional（将单向关联改为双向关联）
* 添加一个反向指针，并使修改函数能够同时更新两条连接
* 如果使用不当，反向指针很容易造成混乱
* 如果某个对象是组成另一对象的部件，那么由后者负责控制关联关系

# Change Bidirectional Association to Unidirectional（将双向关联改为单向关联）
* 去除不必要的关联
* 大量的双向连接也很容易造成“僵尸对象”
