= command =
* request, param, log, queue, undo, redo
* 一个对象化的方法调用

= flyweight =
* 使用共享以高效地支持大量的细粒度对象
* Direct3D和OpenGL都能够实现实例绘制

= observer =
* observer, subject, notify
* 非常适合于一些不相关的模块之间的通信问题
* 不适合于单个紧凑的模块内部的通信
* 为了接收一个通知而去实现整个接口并不符合现在的编程美学
* 更现代的方法倾向于函数式而不是基于类的

= prototype =
* clone, spawner
* 核心思想是一个对象可以生成与自身相似的其他对象
* 适合于游戏里面的数据建模, 重用数据, goblin grunt, goblin wizard, goblin archer

= singleton =
* 不推荐使用
* 直接用静态类

= state =
* enter, exit, update, input
* hero state, weapon state
* state stack, current is at top
* 目标是通过改变主对象代理的对象来改变主对象的行为

= double buffer =
* read buffer a, write buffer b, swap
* 解决的核心问题是对状态同时进行修改与访问的冲突

= game loop =
* render(lag / MS_PER_UPDATE)
* 两个关键部分: 非阻塞的用户输入和帧时间适配

= update method =
* update, elapsed
* 各个对象之间的行为几乎是相互独立的
* 对象的行为与时间相关
* 使用一个单独的集合来维护活跃的对象

= bytecode =
* interpreter, VM, push, pop, lua
* 通过将行为编码成虚拟机指令, 而使其具备数据的灵活性
* 使用情景: 编程语言太底层了, 编写起来繁琐易错; 编译时间太长, 导致迭代缓慢; 确保定义的行为不会让程序崩溃, 需要安全沙箱
* 你会想念调试器的, 静态分析器, 反编译工具等
* 设计有趣的图形化编辑工具, 跨平台的UI框架代价在于亲切感(他们在所有的平台都让人陌生)

= subclass sandbox =

= type object =

= component =

= event queue =

= service locator =

= data locality =

= dirty flag =

= object pool =

= spatial partition =
