敏捷软件开发宣言
================

# 敏捷宣言遵循的原则
* 在团队内部，最有效率也是最有效果的信息传达方式，就是面对面的交谈。

敏捷实践
========

# 敏捷实践
* 这种恐惧激发我们创建一个过程来约束我们的活动，并要求某些输出和制品（artifact）。

# 人和交互重于过程和工具
* 应该首先致力于构建团队，然后在让团队基于需要来配置环境。

# 随时应对变化重于遵循计划
* 较好的做计划的策略是：为下一周做详细的计划，为下3个月做粗略的计划，再以后就做极为简略的计划。

极限编程概述
============

# 结对编程
* 结对编程会极大地促进知识在团队中的传播。

# 隐喻
* 隐喻通常可以归结为一个名字系统。这些名字提供一个系统组成元素的词汇表，并且有助于定义它们之间的关系。

计划
====

# 任务计划
* 开发人员对整个项目了解得越多，那么团队就会越健康、越有知识。我们希望项目的知识能够传播给每一个团队成员，即便这种知识是和他们的专业无关的。

一次编程实践
============

# 结论
* 画一幅图来探究一个想法是没有错的。然而，画一幅图后，不应该假定该图就是相关任务的最好设计。

什么是敏捷设计
==============

# 粘滞性
* 做错误的事情是容易的，但是做正确的事情却很难。

# 软件为何会腐化
* 如果我们的设计由于持续、大量的需求变化而失败，那就表明我们的设计和实践本身是有缺陷的。

# Copy程序的敏捷设计
* 在要实现新需求时，团队抓住这次机会去改进设计，以便设计对于将来的同类变化具有弹性，而不是设法去给设计打补丁。

OCP：开放-封闭原则
==================

# OCP概述
* 对于扩展是开放的（open for extension）。
* 对于修改是封闭的（close for modification）。

# 放置吊钩
* 我们不希望设计背负着许多不必要的抽象。通常，我们更愿意一直等到确实需要那些抽象时再把它放置进去。

DIP：依赖倒置原则
=================

# 结论
* 如果程序的依赖关系是倒置的，它就是面向对象的设计。如果程序的依赖关系不是倒置的，它就是过程化的设计。

使用UML
=======

# 为什么建模
* 构建模型就是为了弄清楚某些东西是否可行。

# 有效的使用UML
* 在和他人交流以及帮助解决设计问题方面，图示是最有用的。

# 项目结束文档
* 编写需要保存的设计文档的最好时机是在项目结束时，并把它作为团队的最后一项工作。这种文档会精确地反映出设计的状态，对后续团队来说非常有用。
* 我们想要的是那些描述系统关键要点的少量重要的图示。

# 迭代式改进
* 人类能够做好的，都是那些采取小步前进然后对结果进行评估的方法所做的事情。而人类做不好的，则都是那些采取大步跳跃的方法所做的事情。

# 图的演化
* 使用白板的目的不是为了让消息序号中的每个点都正确，而是为了让站在白板前的每个人都能理解讨论的内容，是为了赶快停止讨论，开始编码。

状态图
======

# 基础知识
* 实心圆称为初始伪状态
