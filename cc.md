# 糟糕的代码
* 我们都曾经说过有朝一日再回头清理, 当然, 在那些日子里, 我们都没有听过勒布朗(LeBlanc)法则: 稍后等于永不(Later equal never)

# 华丽的新设计
* 新团队的老成员早已不知去向, 而现有成员则要求重新设计一套新系统, 因为这套系统太烂了

# 谜题
* 赶上期限的唯一方法, 做得快的唯一方法, 就是始终尽可能保持代码整洁

# 整洁代码的艺术
* 编写整洁代码的程序员就像是艺术家, 他能用一系列变换把一块白板变作由优雅代码构成的系统

# 什么是整洁代码
* 我喜欢优雅和高效地代码
* 整洁的代码简单直接
* 整洁的代码应该可由作者之外的开发者阅读和增补
* 整洁的代码总是看起来像是某位特别在意它的人写的, 几乎没有改进的余地, 如果你企图改进它, 总会回到原点
* 减少重复代码, 提高表达力, 提早构建简单抽象
* 如果每个例程都让你深合己意, 那就是整洁的代码

# 我们是作者
* 要想干得快, 要想早点做完, 要想轻松写代码, 先让代码易读吧

# 童子军军规
* 让营地比你来时更干净

# 使用读得出来的名称
* 如果名称读不出来, 讨论的时候就会像个傻鸟

# 参数对象
* 若果函数看来需要两个、三个或三个以上参数, 就说明其中一些参数应该封装为类了

# 分隔指令与询问
* 函数要么做什么事, 要么回答什么事, 但二者不可得兼

# 别重复自己
* 重复可能是软件中一切邪恶的根源, 许多原则与实践规则都是为了控制与消除重复而创建

# 如何写出这样的函数
* 我并不从一开始就按照规则写函数, 我想没人做得到

# 小结
* 大师级程序员把系统当做故事来讲, 而不是当作程序来写

# 注释
* 注释的恰当用法是弥补我们在用代码表达意图时遭遇失败
* 注释存在的时间越久, 就离其所描述的代码越远, 越来越变得错误

# 用代码来阐述
* 只需要创建一个描述与注释所言同一事物的函数即可

# TODO注释
* TODO是一种程序员认为应该做, 但由于某些原因目前还没做的工作
* 无论TODO的目的如何, 它都不是在系统中留下糟糕代码的借口

# 喃喃自语
* 如果你决定写注释, 就要花必要的时间确保写出最好的注释

# 多余的注释
* 它就像个自来熟的二手车贩子, 满口保证你不用打开发动机盖查验

# 向报纸学习
* 源文件最顶部应该给出高层次概念和算法, 细节应该往下渐次展开, 直至找到源文件中最底层的函数和细节

# 垂直距离
* 关系密切的概念应该互相靠近

# 垂直距离
* 被调用的函数应该放在执行调用的函数下面

# 横向格式
* 我的个人上限是120个字符

# 数据抽象
* 隐藏实现并非只是在变量之间放上一个函数层那么简单, 隐藏实现关乎抽象

# 浏览和学习边界
* 不要在生产代码中试验新东西, 而是编写测试来遍览和理解第三方代码, 学习性测试(learning tests)

# F.I.R.S.T
* 快速(Fast) 测试应该够快
* 独立(Independent) 测试应该相互独立
* 可重复(Repeatable) 测试应当可在任何环境中重复通过
* 自足验证(Self-Validating) 测试应该有布尔值输出
* 及时(Timely) 测试应及时编写

# 单一权责原则(SRP)
* 类只应有一个权责--只有一条修改的理由
* 你是想把工具归置到有许多抽屉、每个抽屉中装有定义和标记良好的组件的工具箱中呢, 还是想要少数几个能随便把所有东西扔进去的抽屉?

# 内聚
* 类应该只有少量实体变量
* 通常而言, 方法操作的变量越多, 就越黏聚到类上

# 保持内聚性就会得到许多短小的类
* 如果有些函数想要共享某些变量, 为什么不让它们拥有自己的类呢?
* 将大函数拆为许多小函数, 往往也是将类拆分为多个小类的时机

# 为了修改而组织
* 在理想系统中, 我们通过扩展系统而非修改现有代码来添加新特性

# 扩容
* "一开始就做对系统"纯属神话, 反之, 我们应该只去实现今天的用户故事, 然后重构, 明天再扩展系统, 实现新的用户故事, 这就是迭代和增量敏捷的精髓所在

# 优化决策
* 延迟决策至最后一刻也是好手段, 这不是懒惰或不负责任, 它让我们能够基于最有可能的信息做出选择

# 系统需要领域特定语言
* DSL在有效使用时能提升代码惯用法和设计模式之上的抽象层次
* 它允许开发者在恰当的抽象层级上直指代码的初衷

# 通过迭进设计达到整洁目的
* 运行所有测试
* 不可重复
* 表达程序员的意图
* 尽可能减少类和方法的数量

# 不可重复
* "小规模复用"可大量降低系统复杂性

# 表达力
* 我们想要听到好类名和好函数名, 而且在查看其权责时不会大吃一惊

# Args的实现
* 要写出整洁的代码, 必须先写肮脏的代码, 然后再清理它

# 渐进
* 毁坏程序的最好方法之一就是以改进之名大动其结构
* 问题在于, 很难让程序以"改进"之前的方式工作

# 小结
* 满足于仅让代码能工作的程序员不够专业
